### Task Objective
Build a comprehensive cost monitoring system to track AI usage and AWS costs per podcast episode, enabling detailed cost analysis and optimization.

### Current State Assessment
- No cost tracking infrastructure exists
- Episode processing uses Google Gemini (text, image, TTS), AWS Lambda, S3, SES, SQS
- No visibility into per-episode costs or aggregate spending
- Cannot answer "How much did this episode cost?"

### Future State Goal
- Complete cost tracking system with 5 database tables
- Real-time cost event logging for all billable services
- Per-episode cost aggregation and breakdown
- Daily/monthly cost summaries
- Admin dashboard for cost visualization
- 95-99% accuracy in cost calculations

### Implementation Plan

#### Step 1: Database Schema Design ✅
- [x] Design `cost_tracking_events` table for raw cost events
  - [x] Fields: episode_id, podcast_id, event_type, service, quantity, unit, costs, metadata
  - [x] Support for all service types: AI (text/image/TTS), Lambda, S3, SES, SQS
  - [x] JSON metadata for flexible additional data (tokens, duration, retries, etc.)
- [x] Design `episode_costs` table for aggregated per-episode costs
  - [x] Breakdown by service: ai_text, ai_image, ai_tts, lambda, s3_ops, s3_storage, email, sqs
  - [x] Total cost calculation
  - [x] Usage metrics: total_tokens, emails_sent, storage_mb, lambda_duration
- [x] Design `daily_cost_summary` table
  - [x] Daily aggregations: total episodes, total cost, service breakdown
  - [x] Top metrics: avg/max cost per episode, most expensive episode
- [x] Design `monthly_cost_summary` table
  - [x] Monthly aggregations with per-podcast breakdown (JSONB)
  - [x] Total episodes, active podcasts, service totals
- [x] Design `cost_pricing_config` table (dynamic pricing)
  - [x] Service-specific unit costs
  - [x] Effective date ranges for pricing changes
  - [x] Fallback to hardcoded defaults if not configured

#### Step 2: Schema Implementation ✅
- [x] Create `podcasto/src/lib/db/schema/cost-tracking-events.ts`
  - [x] Use Drizzle ORM patterns from existing schema files
  - [x] Add proper indexes for querying by episode_id, podcast_id, timestamp
  - [x] UUID primary keys, timestamp defaults
- [x] Create `podcasto/src/lib/db/schema/episode-costs.ts`
  - [x] Reference episodes table with foreign key
  - [x] Decimal types for cost fields (precision)
  - [x] Unique constraint on episode_id
- [x] Create `podcasto/src/lib/db/schema/daily-cost-summary.ts`
  - [x] Date field with unique index
  - [x] Nullable most_expensive_episode_id reference
- [x] Create `podcasto/src/lib/db/schema/monthly-cost-summary.ts`
  - [x] Composite unique key on (year, month)
  - [x] JSONB for podcast_costs array
- [x] Create `podcasto/src/lib/db/schema/cost-pricing-config.ts`
  - [x] Service + region composite for flexible pricing
  - [x] Effective date ranges with nullable end date
- [x] Update `podcasto/src/lib/db/schema/index.ts` to export new tables
- [x] Update `podcasto/src/lib/db/schema/relations.ts` to add foreign key relationships

#### Step 3: Migration & Deployment ✅
- [x] Migration generated by backend-architect agent
- [x] Applied migration to Supabase via MCP
  - [x] Verified all indexes created
  - [x] Confirmed decimal precision for cost fields
  - [x] Validated foreign key constraints
- [x] Removed old cost tracking tables (ai_usage_logs, aws_usage_logs, cost_aggregations, cost_budgets)
- [x] Verified all 5 new tables created successfully in Supabase

#### Step 4: Core Services - Cost Tracker ✅
- [x] Create `podcasto/src/lib/services/cost-tracker.ts` (147 lines)
  - [x] Export `trackCostEvent()` function
  - [x] Parameters: episodeId, podcastId, eventType, service, quantity, unit, metadata
  - [x] Fetch current pricing from constants
  - [x] Calculate totalCost = quantity × unitCost
  - [x] Insert into cost_tracking_events table
  - [x] Error handling and logging
  - [x] Type-safe with TypeScript interfaces
  - [x] Bonus: `trackCostEventBatch()` for bulk operations
- [x] Types exist in `podcasto/src/types/cost-tracking.ts` (created by backend-architect)
  - [x] CostEventParams interface
  - [x] ServiceType enum
  - [x] EventType enum
  - [x] CostBreakdown interface

#### Step 5: Pricing Configuration ✅
- [x] Create `podcasto/src/lib/constants/pricing.ts`
  - [x] Hardcoded pricing constants for January 2025:
    - [x] Gemini text: $0.00000075 per token (2.0 Flash)
    - [x] Gemini image: $0.01 per image (2.5 Flash Image)
    - [x] Gemini TTS: $0.000002 per token (estimated)
    - [x] Lambda: $0.0000166667 per GB-second
    - [x] S3 PUT: $0.000005 per request
    - [x] S3 GET: $0.00000007 per request
    - [x] S3 Storage: $0.023 per GB-month
    - [x] SES: $0.0001 per email
    - [x] SQS: $0.0000004 per request
  - [x] Export `getUnitCost(service: string)` function
  - [x] Fallback mechanism implemented (hardcoded defaults)

#### Step 6: Cost Calculator Service ✅
- [x] Create `podcasto/src/lib/services/cost-calculator.ts` (150 lines)
  - [x] Export `calculateEpisodeCost({ episodeId })`
  - [x] Fetch all cost_tracking_events for episode
  - [x] Aggregate by service type
  - [x] Calculate storage cost (prorated per day)
  - [x] Sum total tokens across all AI services
  - [x] Insert/update episode_costs table (upsert)
  - [x] Return cost breakdown object
- [x] Helper functions in `cost-calculator-helpers.ts`:
  - [x] `sumCostsByService({ events, services })` - aggregate costs
  - [x] `countByService({ events, service })` - count operations
  - [x] `sumMetadataField({ events, field })` - sum metadata values

#### Step 7: Documentation
- [ ] Create `ProjectDocs/contexts/cost-tracking-schema.md`
  - [ ] Document all 5 tables with field descriptions
  - [ ] ER diagram (text-based)
  - [ ] Relationships and foreign keys
  - [ ] Index strategy
  - [ ] Example queries
- [ ] Update Build Notes with final decisions
  - [ ] Schema choices rationale
  - [ ] Pricing source and update strategy
  - [ ] Known limitations and future improvements

#### Step 8: Testing & Validation
- [ ] Verify database schema in Supabase
  - [ ] Check all tables created
  - [ ] Verify indexes exist
  - [ ] Test foreign key constraints
- [ ] Manual test of cost-tracker service
  - [ ] Insert test cost event
  - [ ] Verify data in database
  - [ ] Test pricing fallback logic
- [ ] Manual test of cost-calculator service
  - [ ] Create mock cost events for test episode
  - [ ] Run calculation
  - [ ] Verify aggregated costs in episode_costs table

### Agent Collaboration Notes

**backend-architect agent:**
- Assigned: Database schema design and migration strategy
- Spec: Section "Step 1: Database Schema Design"
- Decisions to document:
  - Table normalization approach
  - Index strategy for performance
  - Decimal precision for currency
  - JSONB usage for flexibility
- Update this Build Note with final schema decisions

**Status:** ✅ COMPLETED (Phase 1 - Database Foundation)
**Started:** 2025-01-21
**Completed:** 2025-01-21

### Phase 1 Completion Summary

**Delivered:**
1. ✅ 5 database tables (cost_tracking_events, episode_costs, daily_cost_summary, monthly_cost_summary, cost_pricing_config)
2. ✅ Migration applied to Supabase production database
3. ✅ Cost tracker service (`src/lib/services/cost-tracker.ts`) - 147 lines
4. ✅ Cost calculator service (`src/lib/services/cost-calculator.ts`) - 150 lines + helpers
5. ✅ Pricing constants (`src/lib/constants/pricing.ts`)
6. ✅ TypeScript types (`src/types/cost-tracking.ts`)
7. ✅ All code follows .cursorrules standards

**Files Created:**
- `src/lib/db/schema/cost-tracking-events.ts`
- `src/lib/db/schema/episode-costs.ts`
- `src/lib/db/schema/daily-cost-summary.ts`
- `src/lib/db/schema/monthly-cost-summary.ts`
- `src/lib/db/schema/cost-pricing-config.ts`
- `src/lib/services/cost-tracker.ts`
- `src/lib/services/cost-calculator.ts`
- `src/lib/services/cost-calculator-types.ts`
- `src/lib/services/cost-calculator-helpers.ts`
- `src/lib/constants/pricing.ts`
- `drizzle/0006_medical_dakota_north.sql` (migration)

**Database Changes:**
- Added 5 new tables with proper indexes and foreign keys
- Removed 4 old cost tracking tables from previous implementation
- All constraints and relationships validated in Supabase

**Agent Collaboration:**
- backend-architect: Schema design, migration, cost calculator service
- senior-frontend-dev: Cost tracker service implementation

### Notes & Decisions
- Using Drizzle ORM patterns consistent with existing schema files
- Decimal types for all currency fields to avoid floating-point errors
- JSONB for metadata allows flexible tracking without schema changes
- Dynamic pricing via config table, but hardcoded fallback for simplicity (January 2025 pricing)
- Foreign key to episodes table for automatic cleanup on episode deletion
- Unique constraint on episode_costs.episode_id ensures one record per episode
- All services use "use server" directive and follow RORO pattern
- File size limit (150 lines) maintained across all files
- Ready for Phase 2: Next.js instrumentation

### Next Steps (Phase 2)
- Instrument Gemini AI providers to call trackCostEvent()
- Instrument AWS services (S3, SES, SQS)
- Add post-processing integration to call calculateEpisodeCost()
- Create server actions for cost queries
